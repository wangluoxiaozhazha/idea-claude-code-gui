/**
 * SDK Loader - åŠ¨æ€åŠ è½½å¯é€‰ AI SDK
 *
 * æ”¯æŒä»ç”¨æˆ·ç›®å½• ~/.codemoss/dependencies/ åŠ è½½ SDK
 * è¿™å…è®¸ç”¨æˆ·æŒ‰éœ€å®‰è£… SDKï¼Œè€Œä¸æ˜¯å°†å…¶æ‰“åŒ…åœ¨æ’ä»¶ä¸­
 */

import { existsSync, readFileSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';
import { pathToFileURL } from 'url';

// ä¾èµ–ç›®å½•åŸºè·¯å¾„
const DEPS_BASE = join(homedir(), '.codemoss', 'dependencies');

// SDK ç¼“å­˜
const sdkCache = new Map();
// ğŸ”§ åŠ è½½ä¸­çš„ Promise ç¼“å­˜ï¼Œé˜²æ­¢å¹¶å‘åŠ è½½åŒä¸€ SDK
const loadingPromises = new Map();

function getSdkRootDir(sdkId) {
    return join(DEPS_BASE, sdkId);
}

function getPackageDirFromRoot(sdkRootDir, pkgName) {
    // pkgName like: "@anthropic-ai/claude-agent-sdk" or "@openai/codex-sdk"
    const parts = pkgName.split('/');
    return join(sdkRootDir, 'node_modules', ...parts);
}

function pickExportTarget(exportsField, condition) {
    if (!exportsField) return null;
    if (typeof exportsField === 'string') return exportsField;

    // exports: { ".": {...} } or exports: { import: "...", require: "...", default: "..." }
    const root = exportsField['.'] ?? exportsField;
    if (typeof root === 'string') return root;

    if (root && typeof root === 'object') {
        if (typeof root[condition] === 'string') return root[condition];
        if (typeof root.default === 'string') return root.default;
    }

    return null;
}

function resolveEntryFileFromPackageDir(packageDir) {
    // Node ESM does not support importing a directory path directly.
    // We must resolve to a concrete file (e.g., sdk.mjs / index.js / export target).
    const pkgJsonPath = join(packageDir, 'package.json');
    if (existsSync(pkgJsonPath)) {
        try {
            const pkg = JSON.parse(readFileSync(pkgJsonPath, 'utf8'));

            const exportTarget =
                pickExportTarget(pkg.exports, 'import') ??
                pickExportTarget(pkg.exports, 'default');

            const candidate =
                exportTarget ??
                (typeof pkg.module === 'string' ? pkg.module : null) ??
                (typeof pkg.main === 'string' ? pkg.main : null);

            if (candidate && typeof candidate === 'string') {
                return join(packageDir, candidate);
            }
        } catch {
            // ignore and fall through to heuristic
        }
    }

    // Heuristics (covers @anthropic-ai/claude-agent-sdk which has sdk.mjs)
    const heuristicCandidates = ['sdk.mjs', 'index.mjs', 'index.js', 'dist/index.js', 'dist/index.mjs'];
    for (const file of heuristicCandidates) {
        const full = join(packageDir, file);
        if (existsSync(full)) return full;
    }

    return null;
}

function resolveExternalPackageUrl(pkgName, sdkRootDir) {
    // Resolve from package directory (works for external node_modules without touching Node's default resolver)
    const packageDir = getPackageDirFromRoot(sdkRootDir, pkgName);
    const entry = resolveEntryFileFromPackageDir(packageDir);
    if (!entry) {
        throw new Error(`Unable to resolve entry file for ${pkgName} from ${packageDir}`);
    }
    return pathToFileURL(entry).href;
}

/**
 * è·å– Claude SDK çš„å®‰è£…è·¯å¾„
 */
export function getClaudeSdkPath() {
    return join(DEPS_BASE, 'claude-sdk', 'node_modules', '@anthropic-ai', 'claude-agent-sdk');
}

/**
 * è·å– Codex SDK çš„å®‰è£…è·¯å¾„
 */
export function getCodexSdkPath() {
    return join(DEPS_BASE, 'codex-sdk', 'node_modules', '@openai', 'codex-sdk');
}

/**
 * æ£€æŸ¥ Claude Code SDK æ˜¯å¦å¯ç”¨
 */
export function isClaudeSdkAvailable() {
    const sdkPath = getClaudeSdkPath();
    return existsSync(sdkPath);
}

/**
 * æ£€æŸ¥ Codex SDK æ˜¯å¦å¯ç”¨
 */
export function isCodexSdkAvailable() {
    const sdkPath = getCodexSdkPath();
    return existsSync(sdkPath);
}

/**
 * åŠ¨æ€åŠ è½½ Claude SDK
 * @returns {Promise<{query: Function, ...}>}
 * @throws {Error} å¦‚æœ SDK æœªå®‰è£…
 */
export async function loadClaudeSdk() {
    // ğŸ”§ ä¼˜å…ˆè¿”å›å·²ç¼“å­˜çš„ SDK
    if (sdkCache.has('claude')) {
        return sdkCache.get('claude');
    }

    // ğŸ”§ å¦‚æœæ­£åœ¨åŠ è½½ä¸­ï¼Œè¿”å›åŒä¸€ä¸ª Promiseï¼Œé˜²æ­¢å¹¶å‘é‡å¤åŠ è½½
    if (loadingPromises.has('claude')) {
        return loadingPromises.get('claude');
    }

    const sdkPath = getClaudeSdkPath();

    if (!existsSync(sdkPath)) {
        throw new Error('SDK_NOT_INSTALLED:claude');
    }

    // ğŸ”§ åˆ›å»ºåŠ è½½ Promise å¹¶ç¼“å­˜
    const loadPromise = (async () => {
        try {
            const sdkRootDir = getSdkRootDir('claude-sdk');

            // ğŸ”§ Node ESM ä¸æ”¯æŒ import(ç›®å½•)ï¼Œå¿…é¡»è§£æåˆ°å…·ä½“æ–‡ä»¶ï¼ˆå¦‚ sdk.mjsï¼‰
            const resolvedUrl = resolveExternalPackageUrl('@anthropic-ai/claude-agent-sdk', sdkRootDir);
            const sdk = await import(resolvedUrl);

            sdkCache.set('claude', sdk);
            return sdk;
        } catch (error) {
            const pkgDir = getClaudeSdkPath();
            const hintFile = join(pkgDir, 'sdk.mjs');
            const hint = existsSync(hintFile) ? ` Did you mean to import ${hintFile}?` : '';
            throw new Error(`Failed to load Claude SDK: ${error.message}${hint}`);
        } finally {
            // ğŸ”§ åŠ è½½å®Œæˆåæ¸…é™¤ Promise ç¼“å­˜
            loadingPromises.delete('claude');
        }
    })();

    loadingPromises.set('claude', loadPromise);
    return loadPromise;
}

/**
 * åŠ¨æ€åŠ è½½ Codex SDK
 * @returns {Promise<{Codex: Class, ...}>}
 * @throws {Error} å¦‚æœ SDK æœªå®‰è£…
 */
export async function loadCodexSdk() {
    // ğŸ”§ ä¼˜å…ˆè¿”å›å·²ç¼“å­˜çš„ SDK
    if (sdkCache.has('codex')) {
        return sdkCache.get('codex');
    }

    // ğŸ”§ å¦‚æœæ­£åœ¨åŠ è½½ä¸­ï¼Œè¿”å›åŒä¸€ä¸ª Promiseï¼Œé˜²æ­¢å¹¶å‘é‡å¤åŠ è½½
    if (loadingPromises.has('codex')) {
        return loadingPromises.get('codex');
    }

    const sdkPath = getCodexSdkPath();

    if (!existsSync(sdkPath)) {
        throw new Error('SDK_NOT_INSTALLED:codex');
    }

    // ğŸ”§ åˆ›å»ºåŠ è½½ Promise å¹¶ç¼“å­˜
    const loadPromise = (async () => {
        try {
            const sdkRootDir = getSdkRootDir('codex-sdk');
            const resolvedUrl = resolveExternalPackageUrl('@openai/codex-sdk', sdkRootDir);
            const sdk = await import(resolvedUrl);

            sdkCache.set('codex', sdk);
            return sdk;
        } catch (error) {
            throw new Error(`Failed to load Codex SDK: ${error.message}`);
        } finally {
            loadingPromises.delete('codex');
        }
    })();

    loadingPromises.set('codex', loadPromise);
    return loadPromise;
}

/**
 * åŠ è½½ Anthropic åŸºç¡€ SDKï¼ˆç”¨äº API å›é€€ï¼‰
 * @returns {Promise<{Anthropic: Class}>}
 */
export async function loadAnthropicSdk() {
    // ğŸ”§ ä¼˜å…ˆè¿”å›å·²ç¼“å­˜çš„ SDK
    if (sdkCache.has('anthropic')) {
        return sdkCache.get('anthropic');
    }

    // ğŸ”§ å¦‚æœæ­£åœ¨åŠ è½½ä¸­ï¼Œè¿”å›åŒä¸€ä¸ª Promiseï¼Œé˜²æ­¢å¹¶å‘é‡å¤åŠ è½½
    if (loadingPromises.has('anthropic')) {
        return loadingPromises.get('anthropic');
    }

    const sdkRootDir = getSdkRootDir('claude-sdk');
    const sdkPath = join(sdkRootDir, 'node_modules', '@anthropic-ai', 'sdk');

    if (!existsSync(sdkPath)) {
        throw new Error('SDK_NOT_INSTALLED:anthropic');
    }

    // ğŸ”§ åˆ›å»ºåŠ è½½ Promise å¹¶ç¼“å­˜
    const loadPromise = (async () => {
        try {
            const resolvedUrl = resolveExternalPackageUrl('@anthropic-ai/sdk', sdkRootDir);
            const sdk = await import(resolvedUrl);

            sdkCache.set('anthropic', sdk);
            return sdk;
        } catch (error) {
            throw new Error(`Failed to load Anthropic SDK: ${error.message}`);
        } finally {
            loadingPromises.delete('anthropic');
        }
    })();

    loadingPromises.set('anthropic', loadPromise);
    return loadPromise;
}

/**
 * åŠ è½½ Bedrock SDK
 * @returns {Promise<{AnthropicBedrock: Class}>}
 */
export async function loadBedrockSdk() {
    // ğŸ”§ ä¼˜å…ˆè¿”å›å·²ç¼“å­˜çš„ SDK
    if (sdkCache.has('bedrock')) {
        return sdkCache.get('bedrock');
    }

    // ğŸ”§ å¦‚æœæ­£åœ¨åŠ è½½ä¸­ï¼Œè¿”å›åŒä¸€ä¸ª Promiseï¼Œé˜²æ­¢å¹¶å‘é‡å¤åŠ è½½
    if (loadingPromises.has('bedrock')) {
        return loadingPromises.get('bedrock');
    }

    const sdkRootDir = getSdkRootDir('claude-sdk');
    const sdkPath = join(sdkRootDir, 'node_modules', '@anthropic-ai', 'bedrock-sdk');

    if (!existsSync(sdkPath)) {
        throw new Error('SDK_NOT_INSTALLED:bedrock');
    }

    // ğŸ”§ åˆ›å»ºåŠ è½½ Promise å¹¶ç¼“å­˜
    const loadPromise = (async () => {
        try {
            const resolvedUrl = resolveExternalPackageUrl('@anthropic-ai/bedrock-sdk', sdkRootDir);
            const sdk = await import(resolvedUrl);

            sdkCache.set('bedrock', sdk);
            return sdk;
        } catch (error) {
            throw new Error(`Failed to load Bedrock SDK: ${error.message}`);
        } finally {
            loadingPromises.delete('bedrock');
        }
    })();

    loadingPromises.set('bedrock', loadPromise);
    return loadPromise;
}

/**
 * è·å–æ‰€æœ‰ SDK çš„çŠ¶æ€
 */
export function getSdkStatus() {
    return {
        claude: {
            installed: isClaudeSdkAvailable(),
            path: getClaudeSdkPath()
        },
        codex: {
            installed: isCodexSdkAvailable(),
            path: getCodexSdkPath()
        }
    };
}

/**
 * æ¸…é™¤ SDK ç¼“å­˜
 * åœ¨ SDK é‡æ–°å®‰è£…åè°ƒç”¨
 */
export function clearSdkCache() {
    sdkCache.clear();
}

/**
 * æ£€æŸ¥ SDK æ˜¯å¦å®‰è£…å¹¶æŠ›å‡ºå‹å¥½é”™è¯¯
 * @param {string} provider - 'claude' æˆ– 'codex'
 * @throws {Error} å¦‚æœ SDK æœªå®‰è£…
 */
export function requireSdk(provider) {
    if (provider === 'claude' && !isClaudeSdkAvailable()) {
        const error = new Error('Claude Code SDK not installed. Please install via Settings > Dependencies.');
        error.code = 'SDK_NOT_INSTALLED';
        error.provider = 'claude';
        throw error;
    }

    if (provider === 'codex' && !isCodexSdkAvailable()) {
        const error = new Error('Codex SDK not installed. Please install via Settings > Dependencies.');
        error.code = 'SDK_NOT_INSTALLED';
        error.provider = 'codex';
        throw error;
    }
}
