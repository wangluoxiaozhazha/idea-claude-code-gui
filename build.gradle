plugins {
    id 'java'
    id 'checkstyle'
    id 'org.jetbrains.intellij.platform' version '2.10.5'
}

// Load local properties file (not committed to git)
def localPropertiesFile = rootProject.file('local.properties')
def localProperties = new Properties()
if (localPropertiesFile.exists()) {
    localPropertiesFile.withInputStream { localProperties.load(it) }
    println "Loaded local.properties"
}

// Print Java version info
println "Java version: ${System.getProperty('java.version')}"
println "Java home: ${System.getProperty('java.home')}"

// Helper method: prioritize local.properties, fallback to gradle.properties
ext.getLocalProperty = { String key, String defaultValue = null ->
    return localProperties.getProperty(key) ?: project.findProperty(key) ?: defaultValue
}

// Get custom JDK path from local properties (support both property names)
def localJavaHome = getLocalProperty('java.home') ?: getLocalProperty('org.gradle.java.home')

checkstyle {
    toolVersion = '10.12.5'
    configFile = file('checkstyle.xml')
}

group = 'com.github.idea-claude-code-gui'
version = '0.1.5'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17

    // Use Java Toolchain for consistent JDK across all tasks
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

// Configure custom JDK path if specified in local.properties
if (localJavaHome) {
    def javaHomeDir = file(localJavaHome)
    if (javaHomeDir.exists()) {
        println "Using custom Java home: ${localJavaHome}"

        // Set the Java launcher for all JavaExec and Test tasks
        tasks.withType(JavaCompile).configureEach {
            options.fork = true
            options.forkOptions.javaHome = javaHomeDir
        }

        tasks.withType(JavaExec).configureEach {
            javaLauncher = javaToolchains.launcherFor {
                languageVersion = JavaLanguageVersion.of(17)
            }
        }
    } else {
        println "WARNING: Configured java.home does not exist: ${localJavaHome}"
    }
}

repositories {
    mavenCentral()
    intellijPlatform {
        defaultRepositories()
    }
}

dependencies {
    implementation 'com.google.code.gson:gson:2.10.1'

    intellijPlatform {
        def targetIde = project.findProperty('targetIde') ?: 'IC'
        if (targetIde == 'PC') {
            pycharmCommunity('2024.3')
            bundledPlugin('PythonCore')
        } else if (targetIde == 'PY') {
            pycharmProfessional('2024.3')
            bundledPlugin('Pythonid')
        } else {
            intellijIdeaCommunity('2024.3.1')
            bundledPlugin('com.intellij.java')
            // Add Python plugin to support compiling PythonContextCollector
            plugin('PythonCore', '243.22562.145')
        }

        instrumentationTools()
    }
}

sourceSets {
    main {
        java {
            if (project.findProperty('targetIde') == 'PC' || project.findProperty('targetIde') == 'PY') {
                exclude '**/JavaContextCollector.java'
            }
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

// Ensure plugin.xml is patched with the correct since/until build and change notes
patchPluginXml {
    // plugin compatibility range
    sinceBuild = '233'
    untilBuild = '263.*'

    // Release notes shown in plugin repositories
    // Dynamically load the latest changelog entry from CHANGELOG.md and convert to simple HTML.
    def changelogFile = file('CHANGELOG.md')
    def computedChangeNotes = ''
    if (changelogFile.exists()) {
        def lines = changelogFile.readLines('UTF-8')
        // Find first section header (lines starting with '#####')
        def start = -1
        for (int i = 0; i < lines.size(); i++) {
            if (lines[i].trim().startsWith('#####')) {
                start = i
                break
            }
        }

        if (start >= 0) {
            def sb = new StringBuilder()
            boolean inList = false
            int i = start + 1
            while (i < lines.size() && !lines[i].trim().startsWith('#####')) {
                def line = lines[i]
                def t = line.trim()

                if (t.startsWith('- ')) {
                    if (!inList) { sb.append('<ul>'); inList = true }
                    def item = t.substring(2)
                    // remove checkbox markers like [x] or [ ]
                    if (item.startsWith('[') && item.length() > 3 && item.charAt(2) == ']') {
                        item = item.substring(3).trim()
                    }
                    item = item.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                    sb.append('<li>' + item + '</li>')
                } else if (t.startsWith('![') || t.startsWith('<img')) {
                    // skip images
                } else if (t.length() == 0) {
                    if (inList) { sb.append('</ul>'); inList = false }
                    sb.append('<br/>')
                } else {
                    if (inList) { sb.append('</ul>'); inList = false }
                    // paragraph
                    def para = t.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                    sb.append('<p>' + para + '</p>')
                }

                i++
            }
            if (inList) { sb.append('</ul>') }
            computedChangeNotes = sb.toString()
        }
    }

    changeNotes = computedChangeNotes ?: '<p>No changelog found.</p>'
}

// Disable product-specific searchable options/instrument tasks if present
// Use matching to cover task name variants like buildSearchableOptionsIC / buildSearchableOptionsIU etc.
tasks.matching { it.name.startsWith('buildSearchableOptions') }.configureEach {
    enabled = false
}

tasks.named('buildSearchableOptions') {
    enabled = false
}

tasks.named('instrumentCode') {
    enabled = false
}

tasks.named('jarSearchableOptions') {
    enabled = false
}

tasks.named('runIde') {
    jvmArgumentProviders.add({
        [
            '-Djcef.sandbox.enable=false',
            // 禁用插件自动卸载（避免检测到文件变更时自动卸载）
            '-Didea.auto.reload.plugins=false',
            // 禁用插件动态卸载
            '-Didea.dynamic.plugins.allowed=false',
            // 启用内部模式
            '-Didea.is.internal=true',
            // 禁用文件系统事件监控（可选）
            // '-Didea.filewatcher.disabled=true',
            // 增加插件加载超时
            '-Didea.plugins.load.timeout=60000'
        ]
    } as CommandLineArgumentProvider)

    // 设置系统属性
    systemProperty 'idea.auto.reload.plugins', 'false'
    systemProperty 'idea.dynamic.plugins.allowed', 'false'
    systemProperty 'idea.is.internal', 'true'
    systemProperty 'idea.plugin.in.sandbox.mode', 'true'

    // 配置日志输出到控制台
    systemProperty 'idea.log.debug.categories', '#com.github.claudecodegui'

    // 重定向标准输出
    standardOutput = System.out
    errorOutput = System.err

    // 复制自定义配置到sandbox
    doFirst {
        def sandboxConfig = file('sandbox-idea.properties')
        if (sandboxConfig.exists()) {
            def sandboxDir = layout.buildDirectory.dir("idea-sandbox").get().asFile
            def configDir = new File(sandboxDir, 'config')
            configDir.mkdirs()

            copy {
                from sandboxConfig
                into configDir
                rename { 'idea.properties' }
            }
            println "已复制sandbox配置到: ${configDir}/idea.properties"
        }
    }
}

// 统一的 AI Bridge（合并 Claude 和 Codex）
def aiBridgeDir = file("ai-bridge")
def aiBridgePackDir = layout.buildDirectory.dir('ai-bridge-pack').get().asFile
def aiBridgeArchive = new File(aiBridgePackDir, 'ai-bridge.zip')
def aiBridgeHashFile = new File(aiBridgePackDir, 'ai-bridge.hash')

// Build webview automatically
def webviewDir = file('webview')
def requestedTasks = gradle.startParameter.taskNames.collect { it.toLowerCase() }
def enableVConsoleInWebview = requestedTasks.any { it.contains('runide') }

// Get custom Node.js path from local properties
def localNodePath = getLocalProperty('node.path')

tasks.register('buildWebview', Exec) {
    workingDir webviewDir
    environment 'VITE_ENABLE_VCONSOLE', enableVConsoleInWebview ? 'true' : 'false'

    // If custom Node.js path is configured, prepend to PATH environment variable
    if (localNodePath) {
        def nodeFile = file(localNodePath)
        def nodeBinDir = nodeFile.isFile() ? nodeFile.parentFile.absolutePath : nodeFile.absolutePath
        def currentPath = System.getenv('PATH') ?: ''
        environment 'PATH', "${nodeBinDir}${File.pathSeparator}${currentPath}"
        println "Using custom Node.js path: ${localNodePath}"
    }

    if (System.getProperty('os.name').toLowerCase().contains('windows')) {
        commandLine 'cmd', '/c', 'npm', 'run', 'build'
    } else {
        commandLine 'npm', 'run', 'build'
    }

    onlyIf { webviewDir.exists() }
    doFirst { println "Building webview..." }
    doLast { println "Webview build completed." }
}

// Ensure processResources runs after buildWebview
// Use mustRunAfter for execution order, trigger buildWebview before compileJava
tasks.named('compileJava') {
    dependsOn('buildWebview')
}

tasks.named('processResources') {
    mustRunAfter('buildWebview')
}

// 使用系统 zip 命令打包 ai-bridge，保留文件权限
tasks.register('packageAiBridge', Exec) {
    onlyIf { aiBridgeDir.exists() }

    // 切换到 ai-bridge 目录内部进行打包，避免包含顶层目录
    workingDir aiBridgeDir

    // 确保输出目录存在
    doFirst {
        aiBridgePackDir.mkdirs()
        // 删除旧的 zip 文件
        if (aiBridgeArchive.exists()) {
            aiBridgeArchive.delete()
        }
    }

    // 使用系统 zip 命令，-r 递归，-y 保留符号链接
    // 排除 SDK 包（它们将由用户按需安装到 ~/.codemoss/dependencies/）
    if (System.getProperty('os.name').toLowerCase().contains('windows')) {
        // Windows: 使用 PowerShell 排除 SDK 包
        // 创建临时 PowerShell 脚本文件以避免转义问题
        def tempScript = File.createTempFile('ai-bridge-pack', '.ps1')
        tempScript.deleteOnExit()

        def scriptContent = '''
            $excludePatterns = @(
                '*node_modules\\.pnpm*',
                '*node_modules\\@anthropic-ai*',
                '*node_modules\\@openai*'
            )
            $tempDir = Join-Path $env:TEMP "ai-bridge-temp-$(Get-Random)"
            New-Item -ItemType Directory -Path $tempDir -Force | Out-Null
            try {
                Get-ChildItem -Path . -Recurse -Force | Where-Object {
                    $itemPath = $_.FullName
                    $shouldExclude = $false
                    foreach ($pattern in $excludePatterns) {
                        if ($itemPath -like $pattern) {
                            $shouldExclude = $true
                            break
                        }
                    }
                    -not $shouldExclude
                } | ForEach-Object {
                    $relativePath = $_.FullName.Substring((Get-Location).Path.Length + 1)
                    $dest = Join-Path $tempDir $relativePath
                    if ($_.PSIsContainer) {
                        if (-not (Test-Path $dest)) {
                            New-Item -ItemType Directory -Path $dest -Force | Out-Null
                        }
                    } else {
                        $destDir = Split-Path $dest -Parent
                        if (-not (Test-Path $destDir)) {
                            New-Item -ItemType Directory -Path $destDir -Force | Out-Null
                        }
                        Copy-Item $_.FullName -Destination $dest -Force
                    }
                }
                Compress-Archive -Path "$tempDir\\*" -DestinationPath "''' + aiBridgeArchive.absolutePath.replace('\\', '\\\\') + '''" -Force
            } finally {
                if (Test-Path $tempDir) {
                    Remove-Item -Path $tempDir -Recurse -Force
                }
            }
            '''
        tempScript.text = scriptContent
        commandLine 'powershell', '-NoProfile', '-ExecutionPolicy', 'Bypass', '-File', tempScript.absolutePath
    } else {
        // Unix/Linux/macOS: 使用 zip 命令保留权限
        // 排除 SDK 包目录
        commandLine 'zip', '-r', '-y', aiBridgeArchive.absolutePath,
            '.',
            '-x', '*/node_modules/.pnpm/*',
            '-x', '*/node_modules/@anthropic-ai/*',
            '-x', '*/node_modules/@openai/*'
    }

    doLast {
        if (aiBridgeArchive.exists()) {
            println "✓ ai-bridge.zip 已创建: ${aiBridgeArchive.absolutePath}"
            println "  大小: ${aiBridgeArchive.length() / 1024 / 1024} MB"

            // 生成 ai-bridge.hash 文件（SHA-256）
            def digest = java.security.MessageDigest.getInstance('SHA-256')
            aiBridgeArchive.withInputStream { is ->
                byte[] buffer = new byte[8192]
                int read
                while ((read = is.read(buffer)) != -1) {
                    digest.update(buffer, 0, read)
                }
            }
            def hashHex = digest.digest().collect { String.format('%02x', it) }.join('')
            aiBridgeHashFile.text = hashHex
            println "✓ ai-bridge.hash 已创建: ${hashHex}"
        } else {
            throw new GradleException("打包失败: ai-bridge.zip 未生成")
        }
    }
}

// 提取插件名称
def pluginName = project.name

tasks.matching { it.name.startsWith('prepareSandbox') }.configureEach {
    dependsOn('buildWebview', 'packageAiBridge')
    def sandboxRootProvider = layout.buildDirectory.dir('idea-sandbox')
    // 在配置阶段捕获需要的文件引用
    def archiveSource = aiBridgeArchive
    def hashSource = aiBridgeHashFile
    def bridgeDir = aiBridgeDir

    doLast {
        if (!bridgeDir.exists() && !archiveSource.exists()) {
            throw new GradleException('ai-bridge 目录不存在，请确保已拉取并安装依赖。')
        }
        def sandboxRoot = sandboxRootProvider.get().asFile
        def pluginDir = new File(sandboxRoot, "plugins/${pluginName}")

        def extractedDir = new File(pluginDir, 'ai-bridge')
        def archiveTarget = new File(pluginDir, 'ai-bridge.zip')
        def hashTarget = new File(pluginDir, 'ai-bridge.hash')

        // 使用 ant 任务删除和复制，避免使用 project.* 方法
        ant.delete(dir: extractedDir, failonerror: false)
        ant.delete(file: archiveTarget, failonerror: false)
        ant.delete(file: hashTarget, failonerror: false)
        ant.copy(file: archiveSource, todir: pluginDir)
        if (hashSource.exists()) {
            ant.copy(file: hashSource, todir: pluginDir)
        }
    }
}

// 配置 prepareSandbox 之后的任务，确保 ai-bridge.zip 被包含
tasks.matching { it.name == 'preparePluginForDistribution' || it.name == 'composedJar' }.configureEach {
    dependsOn('packageAiBridge')
}

tasks.named('buildPlugin') {
    dependsOn('packageAiBridge', 'checkstyleMain')

    doLast {
        // 解压插件 zip，添加 ai-bridge.zip 和 ai-bridge.hash，然后重新打包
        def distributionFile = archiveFile.get().asFile
        if (distributionFile.exists() && aiBridgeArchive.exists()) {
            def tempDir = file("${layout.buildDirectory.get()}/tmp/plugin-repack")
            delete(tempDir)

            // 解压
            copy {
                from zipTree(distributionFile)
                into tempDir
            }

            // 找到插件目录并添加 ai-bridge.zip 和 ai-bridge.hash
            def pluginDir = new File(tempDir, pluginName)
            if (pluginDir.exists()) {
                copy {
                    from aiBridgeArchive
                    from aiBridgeHashFile
                    into pluginDir
                }

                // 删除 searchableOptions jar（如果存在）
                fileTree(new File(pluginDir, 'lib')).matching {
                    include '**/*searchableOptions*.jar'
                }.each { jarFile ->
                    delete(jarFile)
                    println "已删除 searchableOptions jar: ${jarFile.name}"
                }

                // 重新打包
                delete(distributionFile)
                ant.zip(destfile: distributionFile) {
                    fileset(dir: tempDir)
                }
                println "已将 ai-bridge.zip 和 ai-bridge.hash 添加到插件包并移除 searchableOptions jar"
            }

            delete(tempDir)
        }
    }
}
